 /*
   
  Copyright 2010, Moritz Stefaner

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
   
*/

package eu.stefaner.elasticlists.layout {	import eu.stefaner.elasticlists.ui.contentitem.ContentItemSprite;	import flare.animate.Transitioner;	import flare.vis.operator.layout.Layout;	import flash.geom.Rectangle;	/**	 *	Class description.	 *	 *	@langversion ActionScript 3.0	 *	@playerversion Flash 9.0	 *	 *	@author moritz@stefaner.eu	 *	@since  31.10.2007	 */	public class TileLayout extends Layout {		public var margin : int;		public var layoutMode : int;		public static var FIXED_WIDTH : int = 1;		public static var SCALE_TO_FIXED_WIDTH : int = 2;			public static var FIXED_HEIGHT : int = 3;			public static var SCALE_TO_FIXED_HEIGHT : int = 4;					public static var SCALE_TO_FIXED_SIZE : int = 5;		public function TileLayout(margin : int = 2, layoutMode : int = 2) : void {			this.margin = margin;			this.layoutMode = layoutMode;			layoutBounds = new Rectangle();			super();		}		public override function operate(t : Transitioner = null) : void {			t = Transitioner.instance(t);						// Count number of visible items			var numItems : int = 0;					var w : Number = 0;			var h : Number = 0;						layoutBounds.width = visualization.bounds.width;			layoutBounds.height = visualization.bounds.height;											visualization.data.nodes.visit(function(d : ContentItemSprite):void {				d.updateVisibility(t);									if(d.isVisible) {					numItems++;					if(!w && !h) {						w = d.defaultWidth;						h = d.defaultHeight;												}				}			});									// assumption: all sprites have the same dimensions!			var numCols : int = 100000;			var numRows : int = 100000;			var colWidth : Number = w + margin;									var rowHeight : Number = h + margin;				var scaleFactor : Number = 1;						// TODO:			// THIS IS PRETTY MUCH UNTESTED!			switch (layoutMode) {				case FIXED_WIDTH :									numCols = Math.floor(layoutBounds.width / colWidth);					numRows = Math.ceil(numItems / numCols);					break;									case SCALE_TO_FIXED_WIDTH :						// TODO					numCols = Math.max(1, Math.round(layoutBounds.width / colWidth));					scaleFactor = layoutBounds.width / (numCols * colWidth);					break;				case FIXED_HEIGHT :					numRows = Math.floor(layoutBounds.height / rowHeight);					numCols = Math.ceil(numItems / numRows);					break;									case SCALE_TO_FIXED_HEIGHT :						// TODO					numRows = Math.max(1, Math.round(layoutBounds.height / rowHeight));					scaleFactor = layoutBounds.height / rowHeight;					break;									case SCALE_TO_FIXED_SIZE :						/*					var tempHeight : Number = layoutBounds.height;					var tempWidth : Number = layoutBounds.width;					var lastNumCols : Number = 10000;										// ouch - I guess there is an analytic way to do this ;)					scaleFactor += .01;					while(scaleFactor > 0) {					scaleFactor -= .01;					numCols = Math.floor(tempWidth / (colWidth * scaleFactor));					if(lastNumCols == numCols) continue;					lastNumCols = numCols;					var height : Number = Math.ceil(numItems / numCols) * rowHeight * scaleFactor;					if(height <= tempHeight) {					// we have a winner.					scaleFactor = layoutBounds.width / (numCols * colWidth);					break;					}					}							break;					 * 					 */					numCols = Math.floor(layoutBounds.width / (w + margin));					numRows = Math.ceil(numItems / numCols);					scaleFactor = Math.min(1, (layoutBounds.width - (numCols - 1) * margin) / (numCols * (colWidth - margin)));										while(numRows * h * scaleFactor > (layoutBounds.height - (numRows - 1) * margin)) {						numCols++;						numRows = Math.ceil(numItems / numCols);						scaleFactor = Math.min(1, (layoutBounds.width - (numCols - 1) * margin) / (numCols * (colWidth - margin)));					}					}									colWidth = w * scaleFactor + margin;			rowHeight = h * scaleFactor + margin;			var i : int = 0;			visualization.data.nodes.visit(function(d : ContentItemSprite):void {				if(d.isVisible) {	  	 														t.$(d).x = (i % numCols) * colWidth;					t.$(d).y = Math.floor(i / numCols) * rowHeight;							// overrides default/optimal size settings					t.$(d).width = colWidth - margin;					t.$(d).height = rowHeight - margin;		  	 								i++;				}			});						layoutBounds.height = Math.floor(i / numCols) * rowHeight + rowHeight;			if((i % numCols) == 0) {				// special case: last line was fully filled				layoutBounds.height -= rowHeight;			}		}	}}